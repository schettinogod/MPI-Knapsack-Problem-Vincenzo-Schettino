# -*- coding: utf-8 -*-
"""Vincenzo-Trabalho-Kiko

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f9ZqZbNrhkeUvSx3Cm3aXXmA3fcyJMWq
"""

!pip install mpi4py

# Commented out IPython magic to ensure Python compatibility.
# %%writefile vincenzo.py
# #Carregando as Bibliotecas
# import random
# import sys
# from mpi4py import MPI
# 
# 
# random.seed(1)
# 
# # Gerador de combinações
# def conv_base(num, base, exp):
#     valor = num
#     saida=[]
#     while valor > 0:
#         saida.append(valor % base)
#         valor = valor // base
#     while len(saida) < exp:
#         saida.append(0)
#     saida = [saida[len(saida)-i-1] for i in range(len(saida))]
#     return saida
# 
# #Gerando o intervalo das combinações
# def gera_inter(base, exp, inicio, fim):
#     saida=[]
#     for i in range(inicio, fim):
#         saida.append(conv_base(i, base, exp))
#     return(saida)
# 
# #Gerando a loja
# def gera_loja(tam, max_preco, max_vol):
#     loja=[]
#     for i in range(tam):
#         loja.append((random.randint(1, max_preco), random.randint(1, max_vol)))
#     return loja
# 
# # Cálculo do custo e volume da combinação
# def custo_vol(loja, comb):
# 
#     custo = 0
#     vol = 0
# 
# 
#     for i in range(len(loja)):
#         custo += loja[i][0] * comb[i]
#         vol += loja[i][1] * comb[i]
# 
#     return (custo, vol)
# 
# 
# 
# def div_lista(lista, qtd):
#     tam = len(lista) // qtd # Tamanho de cada lista
#     listas = []
#     for t in range(qtd):
#         inicio = t * tam # marca a posição inicial da lista
#         fim = inicio + tam # marca a posição final da lista
#         print(f'Intervalo {(t+1)}: {(inicio,fim-1)}')
#         aux = []
#         for i in range(inicio, fim):
#             aux.append(lista[i])
#         listas.append(aux)
#         #listas.append([lista[i] for i in range(inicio, fim)])
#         #print(t, qtd - 1, fim, len(lista)) #debug
#         if t == qtd - 1:
#             if fim < len(lista):
#                 for i in range(fim, len(lista)):
#                     listas[t].append(lista[i])
# 
#     return listas
# 
# 
# 
# def main():
# 
#     #Iniciando o MPI
#     comm = MPI.COMM_WORLD
#     pid      = comm.Get_rank()          #PID do Processos atual
#     numProcs = comm.Get_size()          #total de processos iniciados
#     #MaqNome  = MPI.Get_processor_name() #Nome da máquina
# 
#     CAP_MOC = int(sys.argv[1])   # 30
#     TAM_LOJA = int(sys.argv[2])  # 5
#     QTD_PROD = int(sys.argv[3])  # 3
#     MAX_PRECO = int(sys.argv[4]) #20
#     MAX_VOL = int(sys.argv[5])   #10
# 
# 
# 
# 
#     if pid == 0:
# 
#         loja = gera_loja(TAM_LOJA, MAX_PRECO, MAX_VOL)  #gera loja
#         comb = gera_inter(QTD_PROD, TAM_LOJA, 0, QTD_PROD**TAM_LOJA)  #gera combinações
#         print(QTD_PROD**TAM_LOJA)               #printa tamanho da loja
#         listas = div_lista(comb, numProcs)      #divide a lista em varias listas de acordo com o numero de processos e execução inicializa uma lista vazia 'aux'
# 
#         print(len(listas))   #printa lista
#         aux = []   #auxiliar para receber os melhores valores
# #-----------------------------------------------------------------------------
#         lista = listas[0]    #processo 0 recebe a primeira lista
# 
#         #print(f'pid ({pid})')
#         #print(f'pid ({pid}) recebeu lista  ({lista})')
# 
#         #print(f'pid ({pid}) recebeu lista  ({lista})')
# 
#         max = (0, 0)
#         max_comb = []   #salva a melhor combinação
#         for teste in lista:     #calcula o melhor valor na primeira lista (do processo 0)
#           #print(teste)
#           resp = custo_vol(loja, teste)
#           if resp[0] >= max[0] and resp[1] <= CAP_MOC:
#               max = resp
#               max_comb = teste
# 
#         #print(f'pid ({pid}) enviando {max_comb}')
# 
#         aux.append(max_comb)  #adiciona a melhor combinação do processo 0 à variavel auxiliar
#         #print(aux)
# 
# 
# 
# 
#         for proc in range(1, numProcs):   #envia a loja para todos processos exceto o 0
#             comm.send(loja, dest=proc)
# 
#         for proc in range(1, numProcs):   #envia a lista de cada processo
#             comm.send(listas[proc], dest=proc)
# 
# 
# 
# 
#         for proc in range(1, numProcs):   #recebe as melhores combinações de cada processo
#             aux.append(comm.recv(source=proc))
# 
#         print(aux)      #printa as melhores combinações
# 
#         max = (0, 0)
#         max_comb = []
# 
#         for teste in aux:     #calcula a melhor combinação das melhores combinações recebidas dos processos
# 
#           #print(teste)
#           resp = custo_vol(loja, teste)
# 
#           if resp[0] >= max[0] and resp[1] <= CAP_MOC:
#               max = resp
#               max_comb = teste
# 
# 
#         print(loja)     #printa a loja
# 
#         print(max_comb)   #printa a melhor combinação
#         print(max)      #printa os valores da melhor combinação
# 
#     else:
# 
#         loja = comm.recv(source=0)  #recebe a loja do processo 0
#         lista = comm.recv(source=0)  #recebe a lista do processo 0
# 
# 
#         #print(f'pid ({pid})')
#         #print(f'pid ({pid}) recebeu lista  ({lista})')
# 
#         #print(f'pid ({pid}) recebeu lista  ({lista})')
# 
#         max = (0, 0)
#         max_comb = []
#         for teste in lista:   #realiza o teste da melhor combinação do processo atual
#           #print(teste)
#           resp = custo_vol(loja, teste)
#           if resp[0] >= max[0] and resp[1] <= CAP_MOC:
#               max = resp
#               max_comb = teste
# 
#         #print(f'pid ({pid}) enviando {max_comb}')
#         comm.send(max_comb, dest=0)
# 
# 
# if __name__ == '__main__':
#     main()

!mpirun --oversubscribe --allow-run-as-root -np 4 python vincenzo.py 30 5 4 20 10